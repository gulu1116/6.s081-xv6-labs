Lab 7: Multithreading 
============================

Q1: 为什么程序有时候会丢失对哈希表的更新（插入的键消失）？
---------------------------------------------------------------------
程序往哈希表插入数据时，是通过“头插法”把新结点加到桶的链表前面。  
如果两个线程同时往同一个桶插入，可能发生竞争条件：  
- 两个线程都读取了当前桶的头指针；  
- 都各自准备好新结点；  
- 然后各自把新结点写回到桶的头指针。  
这样会导致后写入的线程覆盖掉先写入的线程的结果，导致前一个插入“丢失”。  
原因是插入操作不是原子的。

Q2: 怎么解决这个问题？
------------------------
需要让每个桶的插入操作变成原子操作。最常见的方法是加锁。  
具体做法：为每个桶分配一把互斥锁，在 `put()` 函数里，在调用 `insert()` 之前先加锁，  
插入完成后再解锁。这样保证同一时间只有一个线程能修改该桶，从而避免数据丢失。

Q3: 为什么要为每个桶单独加锁，而不是给整个哈希表加一把锁？
------------------------------------------------------------
如果只用一把全局锁，那么同一时间只有一个线程能执行插入操作，  
所有线程都要串行化，完全失去了并发的意义，性能会很差。  
而如果每个桶单独一把锁，那么不同线程如果访问的是不同的桶，就可以并行插入，  
互不影响，从而提升吞吐量。

Q4: 实验第二部分的 barrier 有什么作用？
---------------------------------------
barrier 的作用是让所有线程在某个“轮次”都到齐之后再一起进入下一轮。  
如果没有 barrier，一些线程可能提前进入下一轮操作，而另一些线程还在上一轮，  
这样就可能访问到不一致的数据，导致错误结果。  
barrier 保证了线程之间的同步。

Q5: barrier 是怎么实现的？
--------------------------
barrier 的实现依赖于：  
- 一把互斥锁（mutex）保护 barrier 的内部状态；  
- 一个计数器 `nthread` 统计已经到达 barrier 的线程数；  
- 一个条件变量（cond）用于让已经到达的线程休眠等待；  
- 当最后一个线程到达时，重置计数器、更新轮次，并调用 `pthread_cond_broadcast`  
  唤醒所有休眠的线程。  

这是 pthread 常见的 barrier 实现方法，基于 `pthread_mutex_t` 和 `pthread_cond_t`。
